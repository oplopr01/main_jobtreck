{
  "version": 3,
  "sources": ["../../tree-changes-hook/src/index.ts", "../../tree-changes/src/index.ts", "../../tree-changes/src/helpers.ts"],
  "sourcesContent": ["import { useEffect, useRef } from 'react';\nimport equal from '@gilbarbara/deep-equal';\nimport treeChanges, { Data, KeyType, TreeChanges } from 'tree-changes';\n\nexport default function useTreeChanges<T extends Data>(value: T) {\n  const previousValue = useRef(value);\n\n  const isEqual = equal(previousValue.current, value);\n  const previousIsEqual = useRef(isEqual);\n\n  const instance = useRef<TreeChanges<KeyType<T, typeof previousValue.current>>>(\n    treeChanges(previousValue.current, value),\n  );\n\n  useEffect(() => {\n    previousValue.current = value;\n  });\n\n  if (previousIsEqual.current !== isEqual || !isEqual) {\n    previousIsEqual.current = isEqual;\n    instance.current = treeChanges(previousValue.current, value);\n  }\n\n  return instance.current;\n}\n\n// eslint-disable-next-line unicorn/prefer-export-from\nexport { treeChanges };\nexport type { Data, KeyType, TreeChanges, Value } from 'tree-changes';\n", "import equal from '@gilbarbara/deep-equal';\nimport is from 'is-lite';\n\nimport { compareNumbers, compareValues, getIterables, includesOrEqualsTo, nested } from './helpers';\nimport { Data, KeyType, TreeChanges, Value } from './types';\n\nexport default function treeChanges<P extends Data, D extends Data, K = KeyType<P, D>>(\n  previousData: P,\n  data: D,\n): TreeChanges<K> {\n  if ([previousData, data].some(is.nullOrUndefined)) {\n    throw new Error('Missing required parameters');\n  }\n\n  if (![previousData, data].every(d => is.plainObject(d) || is.array(d))) {\n    throw new Error('Expected plain objects or array');\n  }\n\n  const added = (key?: K, value?: Value): boolean => {\n    try {\n      return compareValues<K>(previousData, data, { key, type: 'added', value });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const changed = (key?: K | string, actual?: Value, previous?: Value): boolean => {\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is.defined(actual);\n      const hasPrevious = is.defined(previous);\n\n      if (hasActual || hasPrevious) {\n        const leftComparator = hasPrevious\n          ? includesOrEqualsTo(previous, left)\n          : !includesOrEqualsTo(actual, left);\n        const rightComparator = includesOrEqualsTo(actual, right);\n\n        return leftComparator && rightComparator;\n      }\n\n      if ([left, right].every(is.array) || [left, right].every(is.plainObject)) {\n        return !equal(left, right);\n      }\n\n      return left !== right;\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const changedFrom = (key: K | string, previous: Value, actual?: Value): boolean => {\n    if (!is.defined(key)) {\n      return false;\n    }\n\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is.defined(actual);\n\n      return (\n        includesOrEqualsTo(previous, left) &&\n        (hasActual ? includesOrEqualsTo(actual, right) : !hasActual)\n      );\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const decreased = (key: K, actual?: Value, previous?: Value): boolean => {\n    if (!is.defined(key)) {\n      return false;\n    }\n\n    try {\n      return compareNumbers<K>(previousData, data, { key, actual, previous, type: 'decreased' });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const emptied = (key?: K): boolean => {\n    try {\n      const [left, right] = getIterables(previousData, data, { key });\n\n      return !!left.length && !right.length;\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const filled = (key?: K): boolean => {\n    try {\n      const [left, right] = getIterables(previousData, data, { key });\n\n      return !left.length && !!right.length;\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const increased = (key: K, actual?: Value, previous?: Value): boolean => {\n    if (!is.defined(key)) {\n      return false;\n    }\n\n    try {\n      return compareNumbers<K>(previousData, data, { key, actual, previous, type: 'increased' });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const removed = (key?: K, value?: Value): boolean => {\n    try {\n      return compareValues<K>(previousData, data, { key, type: 'removed', value });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  return { added, changed, changedFrom, decreased, emptied, filled, increased, removed };\n}\n\nexport type { Data, KeyType, TreeChanges, Value } from './types';\n", "import equal from '@gilbarbara/deep-equal';\nimport is from 'is-lite';\n\nimport { CompareValuesOptions, Data, Key, Options, ValidTypes, Value } from './types';\n\nexport function canHaveLength(...arguments_: any): boolean {\n  return arguments_.every((d: unknown) => is.string(d) || is.array(d) || is.plainObject(d));\n}\n\nexport function checkEquality(left: Data, right: Data, value: Value) {\n  if (!isSameType(left, right)) {\n    return false;\n  }\n\n  if ([left, right].every(is.array)) {\n    return !left.some(hasValue(value)) && right.some(hasValue(value));\n  }\n\n  /* istanbul ignore else */\n  if ([left, right].every(is.plainObject)) {\n    return (\n      !Object.entries(left).some(hasEntry(value)) && Object.entries(right).some(hasEntry(value))\n    );\n  }\n\n  return right === value;\n}\n\nexport function compareNumbers<K = Key>(\n  previousData: Data,\n  data: Data,\n  options: Options<K>,\n): boolean {\n  const { actual, key, previous, type } = options;\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n\n  let changed =\n    [left, right].every(is.number) && (type === 'increased' ? left < right : left > right);\n\n  if (!is.undefined(actual)) {\n    changed = changed && right === actual;\n  }\n\n  if (!is.undefined(previous)) {\n    changed = changed && left === previous;\n  }\n\n  return changed;\n}\n\nexport function compareValues<K = Key>(\n  previousData: Data,\n  data: Data,\n  options: CompareValuesOptions<K>,\n) {\n  const { key, type, value } = options;\n\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n  const primary = type === 'added' ? left : right;\n  const secondary = type === 'added' ? right : left;\n\n  if (!is.nullOrUndefined(value)) {\n    if (is.defined(primary)) {\n      // check if nested data matches\n      if (is.array(primary) || is.plainObject(primary)) {\n        return checkEquality(primary, secondary, value);\n      }\n    } else {\n      return equal(secondary, value);\n    }\n\n    return false;\n  }\n\n  if ([left, right].every(is.array)) {\n    return !secondary.every(isEqualPredicate(primary));\n  }\n\n  if ([left, right].every(is.plainObject)) {\n    return hasExtraKeys(Object.keys(primary), Object.keys(secondary));\n  }\n\n  return (\n    ![left, right].every(d => is.primitive(d) && is.defined(d)) &&\n    (type === 'added'\n      ? !is.defined(left) && is.defined(right)\n      : is.defined(left) && !is.defined(right))\n  );\n}\n\nexport function getIterables<K = Key>(previousData: Data, data: Data, { key }: Options<K> = {}) {\n  let left = nested(previousData, key);\n  let right = nested(data, key);\n\n  if (!isSameType(left, right)) {\n    throw new TypeError('Inputs have different types');\n  }\n\n  if (!canHaveLength(left, right)) {\n    throw new TypeError(\"Inputs don't have length\");\n  }\n\n  if ([left, right].every(is.plainObject)) {\n    left = Object.keys(left);\n    right = Object.keys(right);\n  }\n\n  return [left, right];\n}\n\nexport function hasEntry(input: Value) {\n  return ([key, value]: [string, Value]) => {\n    if (is.array(input)) {\n      return (\n        equal(input, value) ||\n        input.some(d => equal(d, value) || (is.array(value) && isEqualPredicate(value)(d)))\n      );\n    }\n\n    /* istanbul ignore else */\n    if (is.plainObject(input) && input[key]) {\n      return !!input[key] && equal(input[key], value);\n    }\n\n    return equal(input, value);\n  };\n}\n\nexport function hasExtraKeys(left: string[], right: string[]): boolean {\n  return right.some(d => !left.includes(d));\n}\n\nexport function hasValue(input: Value) {\n  return (value: Value) => {\n    if (is.array(input)) {\n      return input.some(d => equal(d, value) || (is.array(value) && isEqualPredicate(value)(d)));\n    }\n\n    return equal(input, value);\n  };\n}\n\nexport function includesOrEqualsTo<T>(previousValue: T | T[], value: T): boolean {\n  return is.array(previousValue)\n    ? previousValue.some(d => equal(d, value))\n    : equal(previousValue, value);\n}\n\nexport function isEqualPredicate(data: unknown[]) {\n  return (value: unknown) => data.some(d => equal(d, value));\n}\n\nexport function isSameType(...arguments_: ValidTypes[]): boolean {\n  return (\n    arguments_.every(is.array) ||\n    arguments_.every(is.number) ||\n    arguments_.every(is.plainObject) ||\n    arguments_.every(is.string)\n  );\n}\n\nexport function nested<T extends Data, K = Key>(data: T, property?: K) {\n  /* istanbul ignore else */\n  if (is.plainObject(data) || is.array(data)) {\n    /* istanbul ignore else */\n    if (is.string(property)) {\n      const props: Array<any> = property.split('.');\n\n      return props.reduce((acc, d) => acc && acc[d], data);\n    }\n\n    /* istanbul ignore else */\n    if (is.number(property)) {\n      return data[property];\n    }\n\n    return data;\n  }\n\n  return data;\n}\n"],
  "mappings": "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",
  "names": ["is", "equal"]
}
