// src/useClickOutside.ts
import { useEffect as useEffect2, useRef as useRef2 } from "react";

// src/useLatest.ts
import { useEffect, useRef } from "react";
function useLatest(value) {
  const ref = useRef(value);
  useEffect(() => {
    ref.current = value;
  });
  return ref;
}

// src/utils.ts
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function getElement(target) {
  if (!canUseDOM()) {
    return null;
  }
  let targetEl;
  if (typeof target === "string") {
    targetEl = document.querySelector(target);
  } else {
    targetEl = target && "current" in target ? target.current : target;
  }
  return targetEl;
}
function isPlainObject(value) {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.getPrototypeOf({});
}
function isPrimitive(value) {
  return value !== Object(value);
}
function isString(value) {
  return typeof value === "string";
}
function isURL(value) {
  if (!isString(value)) {
    return false;
  }
  try {
    new URL(value);
    return true;
  } catch {
    return false;
  }
}
function noop() {
  return void 0;
}
function on(target, ...rest) {
  if (target && target.addEventListener) {
    target.addEventListener(...rest);
  }
}
function off(target, ...rest) {
  if (target && target.removeEventListener) {
    target.removeEventListener(...rest);
  }
}

// src/useClickOutside.ts
function useClickOutside(callback) {
  const ref = useRef2(null);
  const latestCallback = useLatest(callback);
  useEffect2(() => {
    const handleClick = (event) => {
      if (!ref.current?.contains(event.target)) {
        latestCallback.current();
      }
    };
    on(document, "click", handleClick);
    return () => {
      off(document, "click", handleClick);
    };
  }, [latestCallback]);
  return ref;
}

// src/useDeepCompareEffect.ts
import { useEffect as useEffect3, useRef as useRef3 } from "react";
import deepEqual from "@gilbarbara/deep-equal";
function useDeepCompareEffect(effect, dependencies) {
  if (process.env.NODE_ENV !== "production") {
    if (!(dependencies instanceof Array) || !dependencies.length) {
      console.warn(
        "`useDeepCompareEffect` should not be used with no dependencies. Use React.useEffect instead."
      );
    }
    if (dependencies.length && dependencies.every(isPrimitive)) {
      console.warn(
        "`useDeepCompareEffect` should not be used with dependencies that are all primitive values. Use React.useEffect instead."
      );
    }
  }
  const ref = useRef3(void 0);
  if (!ref.current || !deepEqual(dependencies, ref.current)) {
    ref.current = dependencies;
  }
  useEffect3(effect, ref.current);
}

// src/useDebounce.ts
import { useCallback, useEffect as useEffect4, useRef as useRef5 } from "react";

// src/useIsFirstMount.ts
import { useRef as useRef4 } from "react";
function useIsFirstMount() {
  const isFirstMount = useRef4(true);
  if (isFirstMount.current) {
    isFirstMount.current = false;
    return true;
  }
  return isFirstMount.current;
}

// src/useDebounce.ts
function useDebounce(callback, delayMs = 250, deps = []) {
  const status = useRef5("pending");
  const timeout = useRef5();
  const savedCallback = useRef5(callback);
  const isFirstMount = useIsFirstMount();
  const clear = useCallback(() => {
    status.current = "cancelled";
    timeout.current && clearTimeout(timeout.current);
  }, []);
  const set = useCallback(() => {
    status.current = "pending";
    timeout.current && clearTimeout(timeout.current);
    timeout.current = setTimeout(() => {
      status.current = "completed";
      savedCallback.current();
    }, delayMs);
  }, [delayMs]);
  const getStatus = useCallback(() => status.current, []);
  useEffect4(() => {
    savedCallback.current = callback;
  }, [callback]);
  useDeepCompareEffect(() => {
    if (!isFirstMount) {
      set();
      return clear;
    }
    return void 0;
  }, [set, clear, deps, delayMs]);
  return { cancel: clear, getStatus };
}

// src/useEffectOnce.ts
import { useEffect as useEffect5, useRef as useRef6 } from "react";
function useEffectOnce(effect) {
  const destroyFn = useRef6(null);
  const effectCalled = useRef6(false);
  const effectFn = useRef6(effect);
  useEffect5(() => {
    if (!effectCalled.current) {
      destroyFn.current = effectFn.current();
      effectCalled.current = true;
    }
    return () => {
      if (destroyFn.current) {
        destroyFn.current();
        destroyFn.current = null;
      }
    };
  }, []);
}

// src/useFetch.tsx
import { useCallback as useCallback2, useEffect as useEffect6, useMemo, useRef as useRef7, useState } from "react";
var USE_FETCH_STATUS = {
  IDLE: "IDLE",
  LOADING: "LOADING",
  SUCCESS: "SUCCESS",
  ERROR: "ERROR"
};
async function request(options) {
  const {
    body = void 0,
    headers = {},
    method = "GET",
    mode = "cors",
    type = "json",
    url = ""
  } = options;
  const contentTypes = {
    json: "application/json",
    urlencoded: "application/x-www-form-urlencoded"
  };
  const params = {
    body: void 0,
    cache: "no-store",
    headers: {
      Accept: "application/json",
      "Content-Type": contentTypes[type],
      ...headers
    },
    method,
    mode,
    credentials: void 0
  };
  if (body) {
    params.body = isPlainObject(body) && type === "json" ? JSON.stringify(body) : body;
  }
  return fetch(url, params).then(async (response) => {
    const text = await response.text();
    let content;
    try {
      content = JSON.parse(text);
    } catch {
      content = text;
    }
    if (response.status > 299) {
      const error = new Error(response.statusText);
      error.status = response.status;
      error.response = content;
      throw error;
    }
    return content;
  });
}
function useFetch(urlOrOptions) {
  const isActive = useRef7(false);
  const retryCount = useRef7(0);
  const [{ data, error, status }, setState] = useState({
    data: void 0,
    error: void 0,
    status: USE_FETCH_STATUS.IDLE
  });
  const {
    retry = 0,
    retryDelay = (attempt) => attempt * 1e3,
    wait = false,
    ...options
  } = isURL(urlOrOptions) ? {
    type: "json",
    url: urlOrOptions
  } : urlOrOptions;
  if (!isPlainObject(options) || !isURL(options.url)) {
    throw new Error("Expected an options object or URL");
  }
  const getData = useCallback2(
    (eraseData) => {
      setState((s) => ({
        ...s,
        data: eraseData ? void 0 : s.data,
        error: void 0,
        status: USE_FETCH_STATUS.LOADING
      }));
      request(options).then((response) => {
        if (isActive.current) {
          setState((s) => ({
            ...s,
            data: response,
            status: USE_FETCH_STATUS.SUCCESS
          }));
        }
      }).catch((responseError) => {
        if (isActive.current) {
          setState((s) => ({
            ...s,
            error: responseError,
            status: USE_FETCH_STATUS.ERROR
          }));
        }
        if (retry && retryCount.current < retry) {
          retryCount.current += 1;
          setTimeout(
            getData,
            typeof retryDelay === "function" ? retryDelay(retryCount.current) : retryDelay
          );
        }
      });
    },
    [options, retry, retryDelay]
  );
  useEffect6(() => {
    isActive.current = true;
    return () => {
      isActive.current = false;
    };
  }, []);
  useEffect6(() => {
    if (status === USE_FETCH_STATUS.IDLE && !wait) {
      getData();
    }
  }, [getData, status, wait]);
  const isError = useCallback2(() => status === USE_FETCH_STATUS.ERROR, [status]);
  const isFetched = useCallback2(
    () => [USE_FETCH_STATUS.SUCCESS, USE_FETCH_STATUS.ERROR].includes(status),
    [status]
  );
  const isLoading = useCallback2(() => status === USE_FETCH_STATUS.LOADING, [status]);
  const isPaused = useCallback2(() => status === USE_FETCH_STATUS.IDLE && wait, [status, wait]);
  const isSuccess = useCallback2(() => status === USE_FETCH_STATUS.SUCCESS, [status]);
  const refetch = useCallback2((eraseData = false) => getData(eraseData), [getData]);
  return useMemo(
    () => ({
      data,
      error,
      isError,
      isFetched,
      isLoading,
      isPaused,
      isSuccess,
      refetch,
      status
    }),
    [data, error, isError, isFetched, isLoading, isPaused, isSuccess, refetch, status]
  );
}

// src/useIntersectionObserver.ts
import { useEffect as useEffect7, useMemo as useMemo2, useState as useState2 } from "react";
function useIntersectionObserver(target, options) {
  const { delay = 0, once = false, root = null, rootMargin = "0%", threshold = 0 } = options || {};
  const [value, setValue] = useState2();
  const disabled = value?.isIntersecting && once;
  const observer = useMemo2(() => {
    if (!canUseDOM()) {
      return {};
    }
    return new IntersectionObserver(
      ([entry]) => {
        if (delay) {
          setTimeout(() => setValue(entry), delay);
          return;
        }
        setValue(entry);
      },
      { threshold, root, rootMargin }
    );
  }, [delay, root, rootMargin, threshold]);
  useEffect7(() => {
    if (!canUseDOM() || !(observer instanceof IntersectionObserver) || disabled) {
      return () => void 0;
    }
    const element = getElement(target);
    if (!element) {
      return () => void 0;
    }
    observer.observe(element);
    return () => observer.disconnect();
  }, [target, root, rootMargin, disabled, observer]);
  return value;
}

// src/useInterval.ts
import { useEffect as useEffect8, useRef as useRef8 } from "react";
function useInterval(callback, delayMs = 100) {
  const savedCallback = useRef8(callback);
  useEffect8(() => {
    savedCallback.current = callback;
  });
  useEffect8(() => {
    if (delayMs !== null) {
      const interval = setInterval(() => savedCallback.current(), delayMs);
      return () => {
        clearInterval(interval);
      };
    }
    return void 0;
  }, [delayMs]);
}

// src/useIsMounted.ts
import { useCallback as useCallback3, useEffect as useEffect9, useRef as useRef9 } from "react";
function useIsMounted() {
  const isMounted = useRef9(false);
  useEffect9(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return useCallback3(() => isMounted.current, []);
}

// src/useIsomorphicLayoutEffect.ts
import { useEffect as useEffect10, useLayoutEffect } from "react";
var useIsomorphicLayoutEffect = canUseDOM() ? useLayoutEffect : useEffect10;

// src/useLifecycles.ts
import { useEffect as useEffect11 } from "react";
function useLifecycles(mount, unmount) {
  useEffect11(() => {
    mount();
    return unmount;
  }, []);
}

// src/useLocalStorage.ts
import {
  useCallback as useCallback4,
  useLayoutEffect as useLayoutEffect2,
  useMemo as useMemo3,
  useRef as useRef10,
  useState as useState3
} from "react";
function useLocalStorageHook(key, initialValue, options) {
  if (!key) {
    throw new Error('useLocalStorage: "key" is required');
  }
  const deserializer = useMemo3(
    () => options?.raw ? (value) => value : options?.deserializer ?? JSON.parse,
    [options]
  );
  const serializer = useMemo3(
    () => options?.raw ? String : options?.serializer ?? JSON.stringify,
    [options]
  );
  const initializer = useRef10((k) => {
    try {
      const localStorageValue = localStorage.getItem(k);
      if (localStorageValue !== null) {
        return deserializer(localStorageValue);
      }
      initialValue && localStorage.setItem(k, serializer(initialValue));
      return initialValue;
    } catch {
      return initialValue;
    }
  });
  const [state, setState] = useState3(() => initializer.current(key));
  useLayoutEffect2(() => setState(initializer.current(key)), [key]);
  const set = useCallback4(
    (patch) => {
      try {
        const newState = patch instanceof Function ? patch(state) : patch;
        if (typeof newState === "undefined") {
          return;
        }
        let value;
        if (options) {
          if (options.raw) {
            value = typeof newState === "string" ? newState : JSON.stringify(newState);
          } else if (options?.serializer) {
            value = options.serializer(newState);
          } else {
            value = JSON.stringify(newState);
          }
        } else {
          value = JSON.stringify(newState);
        }
        localStorage.setItem(key, value);
        setState(deserializer(value));
      } catch {
      }
    },
    [deserializer, key, options, state]
  );
  const remove = useCallback4(() => {
    try {
      localStorage.removeItem(key);
      setState(void 0);
    } catch {
    }
  }, [key, setState]);
  return [state, set, remove];
}
function useLocalStorageSSR(_key, initialValue, _options) {
  console.error("`useLocalStorage` is not available.");
  return [initialValue, noop, noop];
}
var useLocalStorage = canUseDOM() ? useLocalStorageHook : useLocalStorageSSR;

// src/useSetState.ts
import { useCallback as useCallback5, useState as useState4 } from "react";
function useSetState(initialState = {}) {
  const [state, set] = useState4(initialState);
  const setState = useCallback5((patch) => {
    set((previousState) => ({
      ...previousState,
      ...patch instanceof Function ? patch(previousState) : patch
    }));
  }, []);
  return [state, setState];
}

// src/useLocalStorageState.ts
function getState(initialState, savedState, shouldOverride, restoreProperties) {
  if (shouldOverride) {
    const initialStateKeys = Object.keys(initialState);
    const savedStateKeys = savedState ? Object.keys(savedState) : [];
    const restorePropertiesKeys = restoreProperties ? Object.keys(restoreProperties) : [];
    if (![...initialStateKeys, ...restorePropertiesKeys].every((k) => savedStateKeys.includes(k))) {
      return { ...initialState, ...restoreProperties };
    }
    return { ...savedState, ...restoreProperties };
  }
  return { ...savedState, ...restoreProperties };
}
function useLocalStorageState(key, initialState, options) {
  const { overrideDivergentSavedState = false, resetProperties } = options || {};
  const [value, setValue, remove] = useLocalStorage(key, initialState);
  const [state, setState] = useSetState(
    getState(initialState, value, overrideDivergentSavedState, resetProperties)
  );
  useDeepCompareEffect(() => {
    setValue(state);
  }, [setValue, state]);
  return [state, setState, remove];
}

// src/useLocation.ts
function useLocation() {
  const { hash, host, hostname, href, origin, pathname, port, protocol, search } = window.location;
  const query = search ? search.slice(1).split("&").reduce((acc, pair) => {
    const [key, value] = pair.split("=");
    if (key && value) {
      acc[key] = value;
    }
    return acc;
  }, {}) : {};
  return { hash, host, hostname, href, origin, pathname, port, protocol, query, search };
}

// src/useMeasure.tsx
import { useState as useState6 } from "react";

// src/defaults.ts
var defaultElementDimensions = {
  absoluteHeight: 0,
  absoluteWidth: 0,
  bottom: 0,
  height: 0,
  left: 0,
  right: 0,
  top: 0,
  width: 0,
  x: 0,
  y: 0
};

// src/useResizeObserver.ts
import { useMemo as useMemo4, useRef as useRef11, useState as useState5 } from "react";
function useResizeObserver(target, debounce = 0) {
  const [element, setElement] = useState5(getElement(target));
  const [value, setValue] = useState5();
  const timeoutRef = useRef11(null);
  const isFirstCall = useRef11(true);
  const observer = useMemo4(() => {
    if (!canUseDOM()) {
      return {};
    }
    return new window.ResizeObserver((entries) => {
      if (debounce && !isFirstCall.current) {
        if (timeoutRef.current) {
          window.clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = window.setTimeout(() => {
          setValue(entries[0]);
        }, debounce);
        return;
      }
      setValue(entries[0]);
      isFirstCall.current = false;
    });
  }, [debounce]);
  useIsomorphicLayoutEffect(() => {
    setElement(getElement(target));
  }, [target]);
  useIsomorphicLayoutEffect(() => {
    if (!canUseDOM() || !(observer instanceof ResizeObserver)) {
      return () => void 0;
    }
    if (!element) {
      return () => void 0;
    }
    observer.observe(element);
    return () => {
      observer.disconnect();
    };
  }, [element, observer]);
  return value;
}

// src/useMeasure.tsx
function parseFloatValue(value) {
  const parsed = parseFloat(value);
  return Number.isNaN(parsed) ? 0 : parsed;
}
function getElementMeasure(element) {
  if (!canUseDOM() || !element) {
    return defaultElementDimensions;
  }
  const { bottom, height, left, right, top, width, x, y } = element.getBoundingClientRect();
  const {
    borderBottom,
    borderLeft,
    borderRight,
    borderTop,
    paddingBottom,
    paddingLeft,
    paddingRight,
    paddingTop
  } = getComputedStyle(element);
  return {
    absoluteHeight: height - parseFloatValue(paddingTop) - parseFloatValue(paddingBottom) - parseFloatValue(borderTop) - parseFloatValue(borderBottom),
    absoluteWidth: width - parseFloatValue(paddingLeft) - parseFloatValue(paddingRight) - parseFloatValue(borderLeft) - parseFloatValue(borderRight),
    bottom,
    height,
    left,
    right,
    top,
    width,
    x,
    y
  };
}
function useMeasure(target, debounce = 0) {
  const [element, setElement] = useState6(getElement(target));
  const [dimensions, setDimensions] = useState6(getElementMeasure(element));
  const entry = useResizeObserver(element, debounce);
  useIsomorphicLayoutEffect(() => {
    const nextElement = getElement(target);
    setElement(nextElement);
    setDimensions(getElementMeasure(nextElement));
  }, [target]);
  useIsomorphicLayoutEffect(() => {
    if (!entry) {
      return;
    }
    const { bottom, height, left, right, top, width, x, y } = entry.contentRect;
    const { blockSize, inlineSize } = entry.borderBoxSize[0];
    setDimensions({
      absoluteHeight: blockSize,
      absoluteWidth: inlineSize,
      bottom,
      height,
      left,
      right,
      top,
      width,
      x,
      y
    });
  }, [entry]);
  return dimensions;
}

// src/useMediaQuery.ts
import { useEffect as useEffect12, useState as useState7 } from "react";
function useMediaQuery(input) {
  const getMatches = (query) => {
    if (!canUseDOM()) {
      return false;
    }
    return window.matchMedia(query).matches;
  };
  const [matches, setMatches] = useState7(getMatches(input));
  function handleChange() {
    setMatches(getMatches(input));
  }
  useEffect12(() => {
    const matchMedia = window.matchMedia(input);
    handleChange();
    try {
      matchMedia.addEventListener("change", handleChange);
    } catch {
      matchMedia.addListener(handleChange);
    }
    return () => {
      try {
        matchMedia.removeEventListener("change", handleChange);
      } catch {
        matchMedia.removeListener(handleChange);
      }
    };
  }, [input]);
  return matches;
}

// src/useMergeRefs.tsx
import { useCallback as useCallback6 } from "react";
function useMergeRefs(...refs) {
  return useCallback6(
    (value) => {
      for (const ref of refs) {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref && typeof ref === "object") {
          ref.current = value;
        }
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    refs
  );
}

// src/useMount.ts
function useMount(fn) {
  useEffectOnce(() => {
    fn();
  });
}

// src/usePrevious.ts
import { useEffect as useEffect13, useRef as useRef12 } from "react";
function usePrevious(state) {
  const ref = useRef12();
  useEffect13(() => {
    ref.current = state;
  });
  return ref.current;
}

// src/useRenderCount.tsx
import { useEffect as useEffect14, useRef as useRef13 } from "react";
function useRenderCount(name) {
  const count = useRef13(1);
  useEffect14(() => {
    count.current += 1;
  });
  console.log(
    `%c${name || "RenderCount"}: %c${count.current}`,
    "font-size: 14px;  font-weight: bold;",
    "color: #999; font-size: 14px;"
  );
  return count.current;
}

// src/useResponsive.tsx
import { useCallback as useCallback7, useEffect as useEffect15, useState as useState8 } from "react";
var defaultBreakpoints = { xs: 0, sm: 400, md: 768, lg: 1024, xl: 1280 };
function useResponsiveBase(breakpoints, initialWidth = Infinity, initialHeight = Infinity) {
  const sizes = Object.entries(breakpoints).sort(([, aSize], [, bSize]) => bSize - aSize);
  const smallestBreakpoint = sizes[sizes.length - 1];
  if (smallestBreakpoint[1] !== 0) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(`The "${smallestBreakpoint[0]}" breakpoint should be 0`);
    }
    smallestBreakpoint[1] = 0;
  }
  const getScreen = useCallback7(() => {
    const height = canUseDOM() ? window.innerHeight : initialHeight;
    const width = canUseDOM() ? window.innerWidth : initialWidth;
    const size = sizes.find(([, s]) => s <= width) || sizes[0];
    const orientation = width > height ? "landscape" : "portrait";
    return {
      between(min, max, andOrientation) {
        return width >= breakpoints[min] && width < breakpoints[max] && (!andOrientation || andOrientation === orientation);
      },
      min(breakpoint, andOrientation) {
        return width >= breakpoints[breakpoint] && (!andOrientation || andOrientation === orientation);
      },
      max(breakpoint, andOrientation) {
        return width < breakpoints[breakpoint] && (!andOrientation || andOrientation === orientation);
      },
      orientation,
      size: size[0]
    };
  }, [breakpoints, initialHeight, initialWidth, sizes]);
  const [screen, setScreen] = useState8(getScreen());
  useEffect15(() => {
    const onResize = () => {
      const current = getScreen();
      if (current.size !== screen.size || current.orientation !== screen.orientation) {
        setScreen(current);
      }
    };
    on(window, "resize", onResize);
    return () => {
      off(window, "resize", onResize);
    };
  }, [getScreen, screen, setScreen]);
  return screen;
}
function useResponsive(breakpoints, initialWidth, initialHeight) {
  return useResponsiveBase(breakpoints || defaultBreakpoints, initialWidth, initialHeight);
}

// src/useScript.tsx
import { useCallback as useCallback8, useEffect as useEffect16, useMemo as useMemo5, useRef as useRef14, useState as useState9 } from "react";
function useScript(src, idOrOptions = {}) {
  const options = useMemo5(
    () => isString(idOrOptions) ? { id: idOrOptions } : idOrOptions,
    [idOrOptions]
  );
  const script = useRef14();
  const [state, setState] = useState9({
    loaded: false,
    error: false
  });
  const onLoad = useCallback8(() => {
    setState({
      loaded: true,
      error: false
    });
  }, []);
  const onError = useCallback8(() => {
    if (script.current) {
      script.current.remove();
    }
    setState({
      loaded: false,
      error: true
    });
  }, []);
  useEffect16(
    () => {
      if (!canUseDOM() || script.current) {
        return void 0;
      }
      const element = document.createElement("script");
      element.async = options.async ?? true;
      element.defer = options.defer ?? false;
      element.type = options.type || "text/javascript";
      element.id = options.id || src;
      element.src = src;
      script.current = element;
      const { current } = script;
      on(current, "load", onLoad);
      on(current, "error", onError);
      document.body.appendChild(current);
      return () => {
        off(current, "load", onLoad);
        off(current, "error", onError);
      };
    },
    [onError, onLoad, options, src]
    // Only re-run effect if script src changes
  );
  return [state.loaded, state.error];
}

// src/useSingleton.tsx
import { useRef as useRef15 } from "react";
function useSingleton(callback) {
  const hasBeenCalled = useRef15(false);
  if (hasBeenCalled.current) {
    return;
  }
  callback();
  hasBeenCalled.current = true;
}

// src/useTimeout.ts
import { useCallback as useCallback9, useEffect as useEffect17, useRef as useRef16 } from "react";
function useTimeout(callback, delayMs = 0) {
  const status = useRef16("pending");
  const timeout = useRef16();
  const savedCallback = useRef16(callback);
  const clear = useCallback9(() => {
    status.current = "cancelled";
    timeout.current && clearTimeout(timeout.current);
  }, []);
  const set = useCallback9(() => {
    status.current = "pending";
    timeout.current && clearTimeout(timeout.current);
    timeout.current = setTimeout(() => {
      status.current = "completed";
      savedCallback.current();
    }, delayMs);
  }, [delayMs]);
  const getStatus = useCallback9(() => status.current, []);
  useEffect17(() => {
    savedCallback.current = callback;
  }, [callback]);
  useEffect17(() => {
    set();
    return clear;
  }, [set, clear]);
  return { cancel: clear, getStatus, reset: set };
}

// src/useThrottle.ts
import { useEffect as useEffect18, useRef as useRef17, useState as useState10 } from "react";

// src/useUnmount.ts
function useUnmount(fn) {
  const unmountFn = useLatest(fn);
  useEffectOnce(() => () => unmountFn.current());
}

// src/useThrottle.ts
function useThrottle(callback, delayMs = 500, trailing = false) {
  const [now, setNow] = useState10(0);
  const callbackRef = useRef17(callback);
  const hasPendingCall = useRef17(false);
  const timer = useRef17();
  useEffect18(() => {
    callbackRef.current = callback;
  }, [callback]);
  useEffect18(() => {
    if (!now) {
      return;
    }
    if (!timer.current) {
      callbackRef.current();
      const timerCallback = () => {
        if (hasPendingCall.current) {
          hasPendingCall.current = false;
          if (trailing) {
            callbackRef.current();
          }
          timer.current = void 0;
        } else {
          timer.current = void 0;
        }
      };
      timer.current = window.setTimeout(timerCallback, delayMs);
    } else {
      hasPendingCall.current = true;
    }
  }, [delayMs, now, trailing]);
  useUnmount(() => {
    window.clearTimeout(timer.current);
    timer.current = void 0;
  });
  return () => setNow(Date.now());
}

// src/useThrottleValue.ts
import { useEffect as useEffect19, useRef as useRef18, useState as useState11 } from "react";
function useThrottleValue(value, delayMs) {
  const [throttledValue, setThrottledValue] = useState11(value);
  const hasNextValue = useRef18(false);
  const nextValue = useRef18(null);
  const timer = useRef18();
  useEffect19(() => {
    if (!timer.current) {
      setThrottledValue(value);
      const timeoutCallback = () => {
        if (hasNextValue.current) {
          hasNextValue.current = false;
          setThrottledValue(nextValue.current);
          timer.current = window.setTimeout(timeoutCallback, delayMs);
        } else {
          timer.current = void 0;
        }
      };
      timer.current = window.setTimeout(timeoutCallback, delayMs);
    } else {
      hasNextValue.current = true;
      nextValue.current = value;
    }
  }, [delayMs, value]);
  useUnmount(() => {
    window.clearTimeout(timer.current);
    timer.current = void 0;
  });
  return throttledValue;
}

// src/useToggle.ts
import { useCallback as useCallback10, useMemo as useMemo6, useReducer } from "react";
function useToggle(initialValue = true) {
  const [value, toggle] = useReducer(
    (state, nextValue) => typeof nextValue === "boolean" ? nextValue : !state,
    initialValue
  );
  const toggleOn = useCallback10(() => toggle(true), []);
  const toggleOff = useCallback10(() => toggle(false), []);
  return useMemo6(() => [value, { toggle, toggleOn, toggleOff }], [value, toggleOn, toggleOff]);
}

// src/useUpdate.ts
import { useReducer as useReducer2 } from "react";
var updateReducer = (number) => (number + 1) % 1e6;
function useUpdate() {
  const [, update] = useReducer2(updateReducer, 0);
  return update;
}

// src/useUpdateEffect.ts
import { useEffect as useEffect20 } from "react";
function useUpdateEffect(effect, deps) {
  const isFirstMount = useIsFirstMount();
  useEffect20(() => {
    if (!isFirstMount) {
      return effect();
    }
    return void 0;
  }, deps);
}

// src/useWhyDidYouUpdate.tsx
import { useEffect as useEffect21, useRef as useRef19, useState as useState12 } from "react";
function useWhyDidYouUpdate(props, nameOrOptions = {}) {
  const [changes, setChanges] = useState12({});
  const previousProps = useRef19();
  const { name, skipLog = false } = isString(nameOrOptions) ? { name: nameOrOptions } : nameOrOptions;
  useEffect21(() => {
    const { current } = previousProps;
    setChanges({});
    if (current) {
      const allKeys = Object.keys({ ...current, ...props });
      const changesObject = {};
      allKeys.forEach((key) => {
        if (current[key] !== props[key]) {
          changesObject[key] = {
            from: current[key],
            to: props[key]
          };
        }
      });
      if (Object.keys(changesObject).length) {
        setChanges(changesObject);
        if (!skipLog) {
          const nameToken = name ? `: ${name}` : "";
          console.log(`[why-did-you-update${nameToken}]`, changesObject);
        }
      }
    }
    previousProps.current = props;
  }, [name, props, skipLog]);
  return Object.keys(changes).length ? changes : false;
}

// src/useWindowSize.ts
import { useEffect as useEffect22, useRef as useRef20, useState as useState13 } from "react";
function useWindowSize(debounce = 0) {
  const [size, setSize] = useState13({
    height: canUseDOM() ? window.innerHeight : 0,
    width: canUseDOM() ? window.innerWidth : 0
  });
  const timeoutRef = useRef20(0);
  const handleResize = useRef20(() => {
    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(() => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }, debounce);
  });
  useEffect22(() => {
    if (!canUseDOM()) {
      return () => void 0;
    }
    const getSize = handleResize.current;
    setSize({
      height: window.innerHeight,
      width: window.innerWidth
    });
    on(window, "resize", getSize);
    return () => {
      off(window, "resize", getSize);
    };
  }, []);
  return size;
}
export {
  USE_FETCH_STATUS,
  useClickOutside,
  useDebounce,
  useDeepCompareEffect,
  useEffectOnce,
  useFetch,
  useIntersectionObserver,
  useInterval,
  useIsFirstMount,
  useIsMounted,
  useIsomorphicLayoutEffect,
  useLatest,
  useLifecycles,
  useLocalStorage,
  useLocalStorageState,
  useLocation,
  useMeasure,
  useMediaQuery,
  useMergeRefs,
  useMount,
  usePrevious,
  useRenderCount,
  useResizeObserver,
  useResponsive,
  useScript,
  useSetState,
  useSingleton,
  useThrottle,
  useThrottleValue,
  useTimeout,
  useToggle,
  useUnmount,
  useUpdate,
  useUpdateEffect,
  useWhyDidYouUpdate,
  useWindowSize
};
//# sourceMappingURL=index.mjs.map