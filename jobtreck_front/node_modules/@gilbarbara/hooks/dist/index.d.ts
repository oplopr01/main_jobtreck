import * as react from 'react';
import { DependencyList, EffectCallback, RefObject, useEffect, Dispatch, SetStateAction, Ref, RefCallback } from 'react';

declare function useClickOutside<T extends Element = HTMLElement>(callback: () => void): react.RefObject<T>;

declare function useDeepCompareEffect<TDeps extends DependencyList>(effect: EffectCallback, dependencies: TDeps): void;

type PlainObject<T = unknown> = Record<PropertyKey, T>;
type Target<T extends Element> = RefObject<T> | T | null | string;
type TimerStatus = 'pending' | 'completed' | 'cancelled';

type UseDebounceStatus = TimerStatus;
interface UseDebounceResult {
    cancel: () => void;
    getStatus: () => UseDebounceStatus;
}
declare function useDebounce(callback: () => void, delayMs?: number, deps?: DependencyList): UseDebounceResult;

declare function useEffectOnce(effect: EffectCallback): void;

declare const USE_FETCH_STATUS: {
    readonly IDLE: "IDLE";
    readonly LOADING: "LOADING";
    readonly SUCCESS: "SUCCESS";
    readonly ERROR: "ERROR";
};
type UseFetchStatus = keyof typeof USE_FETCH_STATUS;
interface UseFetchError extends Error {
    response?: unknown;
    status?: number;
}
interface UseFetchOptions {
    body?: BodyInit | Record<string, any>;
    headers?: PlainObject<string>;
    /**
     * HTTP method.
     * @default: 'GET'
     */
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS' | 'CONNECT' | 'TRACE';
    /**
     * Request mode.
     * @default: 'cors'
     */
    mode?: 'cors' | 'navigate' | 'no-cors' | 'same-origin';
    /**
     * Number of retries.
     */
    retry?: number;
    /**
     * Time to wait before retrying.
     * A function like attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000) applies exponential backoff.
     * A function like attempt => attempt * 1000 applies linear backoff.
     * @default: attempt => attempt * 1000
     */
    retryDelay?: number | ((attempt: number) => number);
    /**
     * Request type.
     * @default: 'json'
     */
    type?: 'json' | 'urlencoded';
    url: string;
    /**
     * Wait for the user to trigger the request.
     * @default: false
     */
    wait?: boolean;
}
interface UseFetchState<TDataType> {
    data?: TDataType;
    error?: UseFetchError;
    status: UseFetchStatus;
}
interface UseFetchResult<TDataType> extends UseFetchState<TDataType> {
    isError: () => boolean;
    isFetched: () => boolean;
    isLoading: () => boolean;
    isPaused: () => boolean;
    isSuccess: () => boolean;
    refetch: (eraseData?: boolean) => void;
}
declare function useFetch<TDataType = unknown>(urlOrOptions: string | UseFetchOptions): UseFetchResult<TDataType>;

interface UseIntersectionObserverOptions extends IntersectionObserverInit {
    /**
     * Delay the response update.
     */
    delay?: number;
    /**
     * Trigger the observer only once.
     */
    once?: boolean;
}
declare function useIntersectionObserver<T extends Element>(target: Target<T>, options?: UseIntersectionObserverOptions): IntersectionObserverEntry | undefined;

declare function useInterval(callback: () => void, delayMs?: number | null): void;

declare function useIsFirstMount(): boolean;

declare function useIsMounted(): () => boolean;

declare const useIsomorphicLayoutEffect: typeof useEffect;

declare function useLatest<T>(value: T): react.MutableRefObject<T>;

declare function useLifecycles(mount: () => void, unmount: () => void): void;

type UseLocalStorageOptions<TValue> = {
    raw: true;
} | {
    deserializer: (value: string) => TValue;
    raw: false;
    serializer: (value: TValue) => string;
};
type UseLocalStorageResult<TValue> = [
    TValue | undefined,
    Dispatch<SetStateAction<TValue | undefined>>,
    () => void
];
declare function useLocalStorageHook<TValue>(key: string, initialValue?: TValue, options?: UseLocalStorageOptions<TValue>): UseLocalStorageResult<TValue>;
declare const useLocalStorage: typeof useLocalStorageHook;

interface UseLocalStorageStateOptions<TState> {
    /**
     * Check if the saved state keys are different from the initial state and override it if needed.
     * @default false
     */
    overrideDivergentSavedState?: boolean;
    /**
     * Reset properties in the saved state.
     */
    resetProperties?: Partial<TState>;
}
type UseLocalStorageStateResult<T> = [
    state: T,
    setState: Dispatch<SetStateAction<Partial<T>>>,
    remove: () => void
];
declare function useLocalStorageState<TState extends PlainObject>(key: string, initialState: TState, options?: UseLocalStorageStateOptions<TState>): UseLocalStorageStateResult<TState>;

interface UseLocationResult {
    hash: string;
    host: string;
    hostname: string;
    href: string;
    origin: string;
    pathname: string;
    port: string;
    protocol: string;
    query: Record<string, string>;
    search: string;
}
declare function useLocation(): UseLocationResult;

interface UseMeasureResult extends Omit<DOMRectReadOnly, 'toJSON'> {
    absoluteHeight: number;
    absoluteWidth: number;
}
declare function useMeasure<T extends Element>(target: Target<T>, debounce?: number): UseMeasureResult;

declare function useMediaQuery(input: string): boolean;

declare function useMergeRefs<T>(...refs: Ref<T>[]): RefCallback<T>;

declare function useMount(fn: () => void): void;

declare function usePrevious<T>(state: T): T | undefined;

declare function useRenderCount(name?: string): number;

declare function useResizeObserver<T extends Element>(target: Target<T>, debounce?: number): ResizeObserverEntry | undefined;

declare const defaultBreakpoints: {
    xs: number;
    sm: number;
    md: number;
    lg: number;
    xl: number;
};
type Breakpoints = typeof defaultBreakpoints;
type UseResponsiveOrientation = 'landscape' | 'portrait';
interface UseResponsiveResult<T> {
    between(min: keyof T, max: keyof T, andOrientation?: UseResponsiveOrientation): boolean;
    max(breakpoint: keyof T, andOrientation?: UseResponsiveOrientation): boolean;
    min(breakpoint: keyof T, andOrientation?: UseResponsiveOrientation): boolean;
    orientation: UseResponsiveOrientation;
    size: keyof T;
}
declare function useResponsive<T extends Record<string, number> | Breakpoints>(breakpoints?: T, initialWidth?: number, initialHeight?: number): UseResponsiveResult<T>;

interface UseScriptOptions {
    async?: boolean;
    defer?: boolean;
    id?: string;
    type?: string;
}
type UseScriptResult = [loaded: boolean, error: boolean];
declare function useScript(src: string, idOrOptions?: string | UseScriptOptions): [loaded: boolean, error: boolean];

type Patch<T> = Partial<T> | ((previousState: T) => Partial<T>);
declare function useSetState<T extends object>(initialState?: T): [T, (patch: Patch<T>) => void];

declare function useSingleton(callback: () => void): void;

type UseTimeoutStatus = TimerStatus;
interface UseTimeoutResult {
    cancel: () => void;
    getStatus: () => UseTimeoutStatus;
    reset: () => void;
}
declare function useTimeout(callback: () => void, delayMs?: number): UseTimeoutResult;

declare function useThrottle<T extends (...arguments_: Array<any>) => void>(callback: T, delayMs?: number, trailing?: boolean): () => void;

declare function useThrottleValue<T>(value: T, delayMs: number): T;

type UseToggleResult = [
    boolean,
    actions: {
        toggle: (nextValue?: boolean) => void;
        toggleOff: () => void;
        toggleOn: () => void;
    }
];
declare function useToggle(initialValue?: boolean): UseToggleResult;

declare function useUnmount(fn: () => any): void;

declare function useUpdate(): () => void;

declare function useUpdateEffect(effect: EffectCallback, deps?: DependencyList): void;

type UseWhyDidYouUpdateResult<T> = {
    [K in keyof T]?: {
        from: any;
        to: any;
    };
};
interface UseWhyDidYouUpdateOptions {
    name?: string;
    skipLog?: boolean;
}
declare function useWhyDidYouUpdate<T extends PlainObject<any>>(props: T, nameOrOptions?: string | UseWhyDidYouUpdateOptions): UseWhyDidYouUpdateResult<T> | false;

interface UseWindowSizeResult {
    height: number;
    width: number;
}
declare function useWindowSize(debounce?: number): UseWindowSizeResult;

export { USE_FETCH_STATUS, type UseFetchOptions, type UseFetchResult, type UseFetchStatus, type UseLocalStorageOptions, type UseLocalStorageResult, type UseLocalStorageStateOptions, type UseLocalStorageStateResult, type UseLocationResult, type UseMeasureResult, type UseResponsiveOrientation, type UseResponsiveResult, type UseScriptResult, type UseTimeoutResult, type UseTimeoutStatus, type UseToggleResult, type UseWhyDidYouUpdateOptions, type UseWhyDidYouUpdateResult, type UseWindowSizeResult, useClickOutside, useDebounce, useDeepCompareEffect, useEffectOnce, useFetch, useIntersectionObserver, useInterval, useIsFirstMount, useIsMounted, useIsomorphicLayoutEffect, useLatest, useLifecycles, useLocalStorage, useLocalStorageState, useLocation, useMeasure, useMediaQuery, useMergeRefs, useMount, usePrevious, useRenderCount, useResizeObserver, useResponsive, useScript, useSetState, useSingleton, useThrottle, useThrottleValue, useTimeout, useToggle, useUnmount, useUpdate, useUpdateEffect, useWhyDidYouUpdate, useWindowSize };
